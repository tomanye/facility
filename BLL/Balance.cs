
// Generated by MyGeneration Version # (1.3.0.3)

using System;
using System.Linq;
using DAL;
using System.Data;
using System.ComponentModel;
using StockoutIndexBuilder;

namespace BLL
{
    /// <summary>
    /// A proxy class to deal with any Item balance related functionality
    /// </summary>
	public class Balance : _Balance
	{
		public Balance()
		{
		
		}

        public DataTable GetBalance(int itemId,int storeId, int month, int year)
        {
            this.FlushData();
            this.Where.WhereClauseReset();
            this.Where.ItemID.Value = itemId;
            this.Where.StoreId.Conjuction = MyGeneration.dOOdads.WhereParameter.Conj.And;
            this.Where.StoreId.Value = storeId;
            this.Where.Month.Conjuction = MyGeneration.dOOdads.WhereParameter.Conj.And;
            this.Where.Month.Value = month;
            this.Where.Year.Conjuction = MyGeneration.dOOdads.WhereParameter.Conj.And;
            this.Where.Year.Value = year;
            this.Query.Load();
            return this.DataTable;
        }

        public static int GetChangeAfterDate(int itemID, int storeID, DateTime date)
        {
            BLL.Balance bal = new Balance();
            string query = String.Format(@"select
                                            ISNULL((select Quantity from receivedoc 
                                            where ItemID={0} and StoreID={1} and Date>{2}),0)
                                            -
                                            ISNULL((select Quantity from IssueDoc 
                                            where ItemID={0} and StoreId={1} and Date>{2}),0)
                                            +
                                            ISNULL((select Quantity from Disposal where 
                                            ItemID={0} and StoreId={1} and Losses<>1 and Date>{2}),0)
                                            -
                                            ISNULL((select Quantity from Disposal where 
                                            ItemID={0} and StoreId={1} and Losses=1 and Date>{2}),0)
                                            as Qty",itemID,storeID,date);
            bal.FlushData();
            bal.LoadFromRawSql(query);
            return int.Parse(bal.GetColumn("Qty").ToString());
        }

        public DataTable GetLastBalance(int itemId, int storeId)
        {
            this.FlushData();
            this.LoadFromRawSql(String.Format("SELECT TOP(1) * FROM Balance WHERE ItemID = {0} AND StoreId= {1} ORDER BY Year DESC, Month DESC",itemId,storeId));
            return this.DataTable;
        }

        public DataTable GetCurrentSOHAsOfDate(int itemId, int storeId, DateTime date)
        {
            
            this.FlushData();
            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@month", date.Month);
            ld.Add("@year", date.Year);
            ld.Add("@days", DateTime.DaysInMonth(date.Year,date.Month));
            
            this.LoadFromSql("SOH", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }
                
        /// <summary>
        /// Makes sure that every quantity in the Loss/Adjustment table is entered as positive.
        /// The Losses are entered with positive quantity and with the Losses bit set to 1.
        /// The adjustments are entered with positive quantity and with the Losses bit set to 0.
        /// </summary>
        public static void GetAndFixLossAdjustmentInconsistencies()
        {
            const string fixQuery = "update disposal set quantity=0-quantity where quantity<0";
            BLL.Balance bal = new Balance();
            bal.LoadFromRawSql(fixQuery);
        }

        /// <summary>
        /// Takes care of double entries in the Inventory Table.  One entered manually and another entered automatically
        /// </summary>
        public static void GetAndFixInventoryInconsistencies()
        {
            const string fixQuery = "delete from yearend where automaticallyentered=1 and itemid in (select itemid from yearend group by itemid,storeid,year having count(*)>1)";
            BLL.Balance bal = new Balance();
            bal.LoadFromRawSql(fixQuery);
        }


        /// <summary>
        /// Gets the average monthly consumption of an item
        /// This method considers the logical store
        /// </summary>
        /// <param name="itemId"></param>
        /// <param name="storeId"></param>
        /// <param name="month"></param>
        /// <param name="year"></param>
        /// <returns></returns>
        public Int64 CalculateAMC(int itemId, int storeId, int month,int year)
        {
            GeneralInfo info = new GeneralInfo();
            info.LoadAll();
            int range = info.AMCRange;
            Int64 cons = 0;
            IssueDoc iss = new IssueDoc();
            int yr = year;// (month > 10) ? year - 1 : year;

            DateTime dt1 = new DateTime(yr,month,DateTime.DaysInMonth(yr,month));
            DateTime dt2 = dt1.AddMonths(-range);
            range = iss.GetAvailableNoOfMonths(itemId, storeId, dt2, dt1);     
            cons = iss.GetIssuedQuantityByDateRange(itemId, storeId, dt2, dt1);
            Int64 AMC = cons / range;
            return AMC;
        }

        /// <summary>
        /// Gets Average Monthly consumption, without considering logical stores
        /// </summary>
        /// <param name="itemId"></param>
        /// <param name="month"></param>
        /// <param name="year"></param>
        /// <returns></returns>
        public Int64 CalculateAMCAll(int itemId, int month, int year)
        {
            GeneralInfo info = new GeneralInfo();
            info.LoadAll();
            int range = info.AMCRange;
            Int64 cons = 0;
            IssueDoc iss = new IssueDoc();
            int yr = (month > 10) ? year - 1 : year;

            DateTime dt1 = new DateTime(yr, month, DateTime.DaysInMonth(yr, month));
            DateTime dt2 = dt1.AddMonths(-range);
            range = iss.GetAvailableNoOfMonthsAll(itemId, dt2, dt1);

            cons = iss.GetIssuedQuantityByDateRangeAll(itemId, dt2, dt1);

            Int64 AMC = cons / range;
            return AMC;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="itemId"></param>
        /// <param name="storeId"></param>
        /// <param name="mon"></param>
        /// <param name="yr"></param>
        /// <returns></returns>
        public Int64 CalculateSOH(int itemId, int storeId, int mon, int yr)
        {
            //ask by normal u get soh on fiscal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();

            int month = (mon > 2)? mon -2 : ((mon ==1 )?11:12);
            int year = (mon > 2) ? yr : yr - 1;
            Int64 cons = 0;
            cons = ( rec.GetReceivedQuantityTillMonth(itemId, storeId, month, year) + dis.GetAdjustedQuantityTillMonth(itemId, storeId, month, year) - iss.GetIssuedQuantityTillMonth(itemId, storeId, month, year) - dis.GetLossesQuantityTillMonth(itemId, storeId, month, year));
            
            return cons;
        }

        /// <summary>
        /// Gets SOH of a specific item for the end of the specified Ethipian Fiscal Month Item
        /// </summary>
        /// <param name="itemId"></param>
        /// <param name="storeId"></param>
        /// <param name="month"></param>
        /// <param name="year"></param>
        /// <returns></returns>

        public Int64 GetSOHOld(int itemId, int storeId, int month, int year)
        {
            //ask by normal u get soh on normal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            //int month = (mon > 2) ? mon - 2 : ((mon == 1) ? 11 : 12);
            //int year = (mon > 2) ? yr : yr - 1;
            Int64 cons = 0;
            long recievedQuantity = rec.GetReceivedQuantityTillMonth(itemId, storeId, month, year);
            long adjustedQuantity = dis.GetAdjustedQuantityTillMonth(itemId, storeId, month, year);
            long issuedQuantity = iss.GetIssuedQuantityTillMonth(itemId, storeId, month, year);
            long lossQuantity = dis.GetLossesQuantityTillMonth(itemId, storeId, month, year);
            long balanceQuantity = yEnd.GetBBalance(year, storeId, itemId, month);
            cons = (balanceQuantity + recievedQuantity + adjustedQuantity - issuedQuantity - lossQuantity);
            this.FlushData();
            // this.LoadFromRawSql(String.Format("SELECT SUM(QuantityLeft) AS Quantity FROM ReceiveDoc WHERE (ItemID = {0}) AND (StoreID = {1} AND ((Month(Date) <= {2} AND Year(Date) = {3}) OR (Month(Date) > 10 AND Year(Date) = {4})))", itemId, storeId, month, year, year - 1));

            // cons = (this.DataTable.Rows[0]["Quantity"].ToString() != "") ? Convert.ToInt64(this.DataTable.Rows[0]["Quantity"]) : 0;

            return cons;

        }

        public double GetSOHAmount(int itemId, int storeId, int month, int year)
        {
            //ask by normal u get soh on normal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            //int month = (mon > 2) ? mon - 2 : ((mon == 1) ? 11 : 12);
            //int year = (mon > 2) ? yr : yr - 1;
            double cons = 0;
            cons = (yEnd.GetBBalanceAmount(year, storeId, itemId,month) + rec.GetReceivedAmount(itemId, storeId, year) + dis.GetAdjustedAmount(itemId, storeId, year) - iss.GetIssuedAmount(itemId, storeId, year) - dis.GetLossesAmount(itemId, storeId, year));
            this.FlushData();
            // this.LoadFromRawSql(String.Format("SELECT SUM(QuantityLeft) AS Quantity FROM ReceiveDoc WHERE (ItemID = {0}) AND (StoreID = {1} AND ((Month(Date) <= {2} AND Year(Date) = {3}) OR (Month(Date) > 10 AND Year(Date) = {4})))", itemId, storeId, month, year, year - 1));

            // cons = (this.DataTable.Rows[0]["Quantity"].ToString() != "") ? Convert.ToInt64(this.DataTable.Rows[0]["Quantity"]) : 0;

            return cons;
        }

        public Int64 GetSOHAll(int itemId, int month, int year)
        {
            //ask by normal u get soh on normal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            Int64 cons = 0;
            cons = (yEnd.GetBBalanceAll(year, itemId) + rec.GetReceivedQuantityTillMonthAll(itemId, month, year) + dis.GetAdjustedQuantityTillMonthAll(itemId, month, year) - iss.GetIssuedQuantityTillMonthAll(itemId, month, year) - dis.GetLossesQuantityTillMonthAll(itemId, month, year));
            this.FlushData();
            return cons;
        }

        public Int64 GetSOHPastMonth(int itemId, int storeId, int month, int year)
        {
            //ask by normal u get soh on normal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            //int month = (mon > 2) ? mon - 2 : ((mon == 1) ? 11 : 12);
            //int year = (mon > 2) ? yr : yr - 1;
            Int64 cons = 0;
            cons = ( rec.GetReceivedQuantityPastMonth(itemId, storeId, month, year) + dis.GetAdjustedQuantityPastMonth(itemId, storeId, month, year) - iss.GetIssuedQuantityPastMonth(itemId, storeId, month, year) - dis.GetLossesQuantityPastMonth(itemId, storeId, month, year));
            this.FlushData();
            // this.LoadFromRawSql(String.Format("SELECT SUM(QuantityLeft) AS Quantity FROM ReceiveDoc WHERE (ItemID = {0}) AND (StoreID = {1} AND ((Month(Date) <= {2} AND Year(Date) = {3}) OR (Month(Date) > 10 AND Year(Date) = {4})))", itemId, storeId, month, year, year - 1));

            // cons = (this.DataTable.Rows[0]["Quantity"].ToString() != "") ? Convert.ToInt64(this.DataTable.Rows[0]["Quantity"]) : 0;

            return cons;

        }

        public Int64 GetSOHperMonth(int itemId, int storeId, int month, int year)
        {
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            //int month = (mon > 2) ? mon - 2 : ((mon == 1) ? 11 : 12);
            //int year = (mon > 2) ? yr : yr - 1;
            Int64 cons = 0;
            cons = (this.GetSOH(itemId,storeId,month -1,year) + rec.GetReceivedQuantityPerMonth(itemId, storeId, month, year) + dis.GetAdjustedQuantityPerMonth(itemId, storeId, month, year) - iss.GetIssuedQuantityPerMonth(itemId, storeId, month, year) - dis.GetLossesQuantityPerMonth(itemId, storeId, month, year));
            
            return cons;
        }

        public int CountStockIn(int storeId,int month,int year)
        {

            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Normal"
                               select m).AsDataView().Count;
            return items;
        }

        public int CountBelowMin(int storeId, int month, int year)
        {
            Items itm = new Items();
            DataTable dtItem = itm.GetAllItems(1);
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            int count = 0;
            Balance bal = new Balance();
            if (storeId == 0)
            {
                count += (from DataRow dr in dtItem.Rows
                          let AMC = bal.CalculateAMCAll(Convert.ToInt32(dr["ID"]), month, year)
                          let MinCon = AMC*min
                          let maxCon = AMC*max
                          let eopCon = AMC*(eop + 0.25)
                          let SOH = bal.GetSOHAll(Convert.ToInt32(dr["ID"]), month, year)
                          let MOS = (AMC != 0) ? (SOH/AMC) : 0
                          let reorder = (maxCon > SOH) ? maxCon - SOH : 0
                          where SOH > eopCon && (SOH <= MinCon)
                          select MinCon).Count();
            }
            else
            {
                count += (from DataRow dr in dtItem.Rows
                          let AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year)
                          let MinCon = AMC*min
                          let maxCon = AMC*max
                          let eopCon = AMC*(eop + 0.25)
                          let SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year)
                          let MOS = (AMC != 0) ? (SOH/AMC) : 0
                          let reorder = (maxCon > SOH) ? maxCon - SOH : 0
                          where SOH > eopCon && (SOH <= MinCon)
                          select MinCon).Count();
            }
            return count;
        }

        public DataTable GetStockIn(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            DataTable items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Normal"
                               select m).CopyToDataTable();
            return items;
            //Items itm = new Items();
            //DataTable dtItem = itm.GetAllItems(1);
            //DataTable dt = new DataTable();
            //string[] cols = {"ID","ItemName","DosageForm","Strength","Unit","StockCode" };
            //foreach (string st in cols)
            //{
            //    dt.Columns.Add(st);
            //}
            //GeneralInfo pipline = new GeneralInfo();
            //pipline.LoadAll();
            //int min = pipline.Min;
            //int max = pipline.Max;
            //double eop = pipline.EOP;
            //int count = 0;
            //Balance bal = new Balance();
            //foreach (DataRow dr in dtItem.Rows)
            //{
            //    Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
            //    Int64 MinCon = AMC * min;
            //    Int64 maxCon = AMC * max;
            //    double eopCon = AMC * (eop + 0.25);
            //    Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
            //    decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
            //    Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
            //    if (SOH > eopCon && (SOH < maxCon || maxCon == 0))
            //    {
            //        object[] obb = { dr["ID"], dr["ItemName"], dr["DosageForm"], dr["Strength"], dr["Unit"],dr["StockCode"] };
            //        dt.Rows.Add(obb);
            //    }
            //    //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            //}
            //return dt;
        }

        public DataTable GetBelowMin(int storeId, int month, int year)
        {
            Items itm = new Items();
            DataTable dtItem = itm.GetAllItems(1);
            DataTable dt = new DataTable();
            string[] cols = { "ID", "ItemName", "DosageForm", "Strength", "Unit", "StockCode" };
            foreach (string st in cols)
            {
                dt.Columns.Add(st);
            }
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
          
            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                if (SOH > eopCon && (SOH <= MinCon))
                {
                    object[] obb = { dr["ID"], dr["ItemName"], dr["DosageForm"], dr["Strength"], dr["Unit"], dr["StockCode"] };
                    dt.Rows.Add(obb);
                }
                //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            }
            return dt;
        }

        public int CountNearEOP(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                         where m["Status"].ToString() == "Near EOP"
                         select m).AsDataView().Count;
            return items;            
        }

        public int CountBelowEOP(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                         where m["Status"].ToString() == "Below EOP"
                         select m).AsDataView().Count;
            return items;
          
        }

        public DataTable GetNearEOP(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            DataTable items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Near EOP"
                               select m).CopyToDataTable();
            return items;

        }

        public DataTable GetBelowEOP(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            DataTable items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Below EOP"
                               select m).CopyToDataTable();
            return items;
        }

        public int CountStockOut(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Stock Out" //&& (Convert.ToInt32(m["SOH"]) > 0 || Convert.ToInt32(m["AMC"]) > 0)
                               select m).AsDataView().Count;
            return items;
         
        }

        public DataTable GetStockOut(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            DataTable items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Stock Out"
                               select m).CopyToDataTable();
            return items;
            
        }

        public DataTable GetReceivedStockOut(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            DataTable items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Stock Out" && Convert.ToInt32(m["Received"]) > 0
                               select m).CopyToDataTable();
            return items;
          
        }

        public int CountOverStock(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Over Stocked"
                               select m).AsDataView().Count;
            return items;

            
        }

        public DataTable GetOverStock(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            DataTable items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Over Stocked"
                               select m).CopyToDataTable();
            return items;
           
        }

        public int CountFreeItemsStockOut(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Stock Out" && (Convert.ToInt32(m["AMC"]) > 0 || Convert.ToInt32(m["SOH"]) > 0) 
                               select m).AsDataView().Count;
            return items;
          
        }

        public DataTable GetFreeItemsStockOut(int storeId, int month, int year)
        {

            GetSOH(storeId, month, year);
            DataTable items = (from m in this.DataTable.AsEnumerable()
                         where m["Status"].ToString() == "Stock Out"
                         select m).CopyToDataTable();
            return items;
           
        }

        public int CountVitalItemsStockOut(int storeId, int month, int year)
        {
            Items itm = new Items();
            DataTable dtItem = itm.GetVitalItems();
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            int count = 0;
            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 minCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                if (SOH == 0)
                    count++;
                //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            }
            return count;
        }

        public int CountECLSItemsStockOut(int storeId, int month, int year)
        {
            Items itm = new Items();
            Programs prog = new Programs();
            prog.GetProgramByName("Family Planning");
            DataTable dtItem = itm.GetItemsByProgram(prog.ID);
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            int count = 0;
            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                if (SOH == 0)
                    count++;
                //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            }
            return count;
        }

        public DataTable GetECLSItemsStockOut(int storeId, int month, int year)
        {
            Items itm = new Items();
            Programs prog = new Programs();
            prog.GetProgramByName("Family Planning");
            DataTable dtItem = itm.GetItemsByProgram(prog.ID);
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
           
            DataTable dt = new DataTable();
            string[] cols = { "ID", "FullItemName", "DosageForm", "Strength", "Unit", "StockCode" };
            foreach (string st in cols)
            {
                dt.Columns.Add(st);
            }
            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                
                if (SOH == 0)
                {
                    object[] obb = { dr["ID"], dr["ItemName"], dr["DosageForm"], dr["Strength"], dr["Unit"], dr["StockCode"] };
                    dt.Rows.Add(obb);
                }
                //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            }
            return dt;
        }

        public DataTable GetVitalItemsStockOut(int storeId, int month, int year)
        {
            Items itm = new Items();
            DataTable dtItem = itm.GetVitalItems();
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();

            DataTable dt = new DataTable();
            string[] cols = { "ID", "ItemName", "DosageForm", "Strength", "Unit", "StockCode" };
            foreach (string st in cols)
            {
                dt.Columns.Add(st);
            }

            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
           
            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                if (SOH == 0)
                {
                    object[] obb = { dr["ID"], dr["ItemName"], dr["DosageForm"], dr["Strength"], dr["Unit"], dr["StockCode"] };
                    dt.Rows.Add(obb);
                }
            }
            return dt;
        }

        //DU Info

        public Int64 CalculateDUAMC(int itemId, int receivingUnit, int month, int year, int LastSOH)
        {
            GeneralInfo info = new GeneralInfo();
            info.LoadAll();
            int range = 3;
            try
            {
                range = info.DUAMCRange;
            }
            catch
            { }
            Int64 cons = 0;
            IssueDoc iss = new IssueDoc();

            int yr = (month > 10) ? year + 1 : year;

            DateTime dt1 = new DateTime(yr, month, DateTime.DaysInMonth(yr, month));
            DateTime dt2 = dt1.AddMonths(-range);
            int mon = dt2.Month;
            range = iss.GetAvailableNoOfMonthsDU(itemId, receivingUnit, dt2, dt1);
            yr = (mon > 10) ? year + 1 : year;
            cons = iss.GetDUConsumptionAfterMonth(itemId, receivingUnit, mon, yr);

            //for (int m = mon+1; m < month; m++ )
            //{
            //    yr = (m > 10) ? year - 1 : year;
            //    cons = cons + iss.GetDUConsumptionByMonth(itemId, receivingUnit, m, yr);
            //}
            yr = (month > 10) ? year + 1 : year;
            //yr = (month > 10) ? year : year  + 1 ;
            //Int64 lastIss = iss.GetDUIssueByMonth(itemId, receivingUnit, month, yr);
            Int64 lastIss = iss.GetDULastIssueQty(itemId, receivingUnit);
           // lastIss = ((lastIss > 0)? (lastIss - LastSOH) : lastIss );
            cons = cons + lastIss - LastSOH;
            //cons = cons - LastSOH;
            cons = ((cons > 0)?cons: 0);
            Int64 AMC = cons / range;
            return AMC;
        }

        public Int64 GetDUSOH(int itemID, int receivingUnit,int month,int year)
        {
            Int64 quantity = 0;
            int yr = ((month > 10)?year:year+1);
            IssueDoc iss = new IssueDoc();
            quantity = iss.GetDUSOHByMonth(itemID,receivingUnit,month,yr);
            return quantity;
        }

        public DataTable CostBalanceByYear(int storeId, int year,int month, BackgroundWorker bw)
        {
            DataTable dtBal = new DataTable();
            GeneralInfo pipline = new GeneralInfo();
         
            // Dont Iterate
            DataTable dtbl = new DataTable();
            dtbl = GetSOH(storeId, month, year);
            return dtbl;
        }

        public DataTable ConsumptionByUnit(int storeId, int year, int programID, BackgroundWorker bw)
        {
            // Dont Iterate
            DataTable dtbl = new DataTable();
            //if (programID == 0) //We don't filter by program ID.
            //{
            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@year", year);

            ////this.LoadFromSqlNoExec("SOH", ld);
            this.LoadFromSql("GetMonthlyConsumptionByUnits", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }

        public DataTable ConsumptionTrendByMonth(int storeId, int year, int programID, BackgroundWorker bw)
        {
            // Dont Iterate
            DataTable dtbl = new DataTable();
            //if (programID == 0) //We don't filter by program ID.
            //{
                System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
                ld.Add("@storeid", storeId);
                ld.Add("@year", year);

                ////this.LoadFromSqlNoExec("SOH", ld);
                this.LoadFromSql("GetConsumptionTrendByMonth", ld, CommandType.StoredProcedure);
                return this.DataTable;
            //}
            //else //We filter by program ID.
            //{
            //    dtbl = GetSOHByPrograms(storeId, programID, month, year);
            //}
           // return dtbl;
        }


        public DataTable BalanceOfAllItems(int storeId, int year, int month,string selectedType,int programID,int commodityTypeID, DateTime dtCurrent, BackgroundWorker bw)
        {
            DataTable dtBal = new DataTable();
            GeneralInfo pipline = new GeneralInfo();
            
            // Dont Iterate
            DataTable dtbl=new DataTable();
            if (programID == 0) //We don't filter by program ID.
            {
                dtbl = GetSOH(storeId, month, year);
            }
            else //We filter by program ID.
            {
              //  dtbl = GetSOHByPrograms(storeId,commodityTypeID, programID, month, year);
                dtbl = GetSOHByPrograms(storeId,programID, month, year);
            }            
            
            dtbl.Columns.Add("MOS",typeof(float));
            dtbl.Columns.Add("ReorderAmount", typeof(int));
           // dtbl.Columns.Add("DaysStockedOut", typeof(int));
            //dtbl.Columns.Add("amc", typeof(double));
            int amc;
            foreach (DataRow dr in dtbl.Rows)
            {
               amc = Convert.ToInt32(dr["AMC"]);
                if (amc > 0)
                {
                    dr["MOS"] = Convert.ToDouble(dr["SOH"]) / amc;
                }
                else
                {
                    dr["MOS"] = 0;
                }
                // 
                int reorder =  Convert.ToInt32(dr["Max"]) - Convert.ToInt32(dr["SOH"]);
                dr["ReorderAmount"] = (reorder < 0) ? 0 : reorder;
               
            }
            return dtbl;

          }

        public DataTable GetSOH(int storeId, int month, int year)
        {
            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@month", month);
            ld.Add("@year", year);
            
            ld.Add("@days", DateTime.DaysInMonth(year, month));
            
            ////this.LoadFromSqlNoExec("SOH", ld);
            this.LoadFromSql("SOH", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }

        public Int64 GetSOH(int itemID, int storeId, int month, int year)
        {
            //System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            //ld.Add("@storeid", storeId);
            //ld.Add("@month", month);
            //ld.Add("@year", year);
            //ld.Add("@days", DateTime.DaysInMonth(year, month));

            //LoadFromSql("SOH", ld, CommandType.StoredProcedure);
            GetSOH(storeId, month, year);
            while (!this.EOF)
            {
                if (this.ID == itemID)
                {
                    return this.SOH;
                }
                this.MoveNext();
            }
            return 0;
        }

        public DataTable GetBinCard(int storeID, int itemID, int year)
        {
            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@StoreID", storeID);
            ld.Add("@ItemID", itemID);
            ld.Add("@Year", year);
            
            LoadFromSql("rpt_Bincard", ld, CommandType.StoredProcedure);
            
            // Set the balance  
            int balance = (int)GetBeginningBalance(year,itemID,storeID);
            while (!EOF)
            {
                balance += Convert.ToInt32(GetColumn("Balance"));
                SetColumn("Balance",balance);
                MoveNext();
            }

            return this.DataTable;
        }

        public DataTable GetSOHByPrograms(int storeId, int programid, int month, int year)
        {
            var days = DateTime.DaysInMonth(year, month);
            var ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@progID", programid);
            ld.Add("@month", month);
            ld.Add("@year", year);
            ld.Add("@days", days);
            this.LoadFromSql("SOHByPrograms", ld, CommandType.StoredProcedure);
            //TODO: filter out by commodity type here.

            return this.DataTable;

        }

        public DataTable GetSOHToDate(int storeId, DateTime dt)
        {
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            
            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@date1", dt);
            
            ld.Add("@amcrange", pipline.AMCRange);
            ld.Add("@min", pipline.Min);
            ld.Add("@max", pipline.Max);
            ld.Add("@eop", pipline.EOP);

            //this.LoadFromSqlNoExec("SOH", ld);
            this.LoadFromSql("SOHByDate", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }


        public DataTable OverStockedItems (int storeId, int year, int month, string selectedType, BackgroundWorker bw)
        {
            DataTable dtBal = new DataTable();
            GeneralInfo pipline = new GeneralInfo();
            Items itm = new Items();
            Balance bal = new Balance();
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            string[] str = { "FullItemName", "SOH", "AMC", "MOS", "Min", "Max","ExcessQty","ExcessAmount", "CategoryId", "SubCategoryID", "ID" };
            foreach (string s in str)
            {
                dtBal.Columns.Add(s);
            }
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            DataTable dtItem = new DataTable();

                dtItem = ((selectedType == "Drug") ? itm.GetAllItems(1) : itm.GetAllSupply());
                int i = 1;
            foreach (DataRow dr in dtItem.Rows)
            {
                
                string itemName = dr["FullItemName"].ToString();
                int yer = (month < 11) ? year : year - 1;
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, yer);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, yer);
                if (SOH > maxCon)
                {
                    decimal MOS = (AMC != 0) ? (Convert.ToDecimal(SOH) / Convert.ToDecimal(AMC)) : 0;
                    MOS = Decimal.Round(MOS, 1);

                    Int64 excessQty = SOH - maxCon;
                    double price = rec.GetLastReceivedCost(Convert.ToInt32(dr["ID"]), storeId);
                    double excessAmount = price * excessQty;
                    object[] obj = { itemName, SOH, AMC, MOS, MinCon, maxCon, excessQty, excessAmount, Convert.ToInt32(dr["CategoryId"]), Convert.ToInt32(dr["SubCategoryID"]), Convert.ToInt32(dr["ID"]) };
                    dtBal.Rows.Add(obj);
                }
                bw.ReportProgress(Convert.ToInt32((Convert.ToDouble(i++) / dtItem.Rows.Count) * 100));
            }
            return dtBal;
        }

        public DataTable BalanceAllItems(int storeId, int year, int month, string selectedType)
        {
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            Items itm = new Items();
            DataTable dtResult = new DataTable();
            string[] col = { "FullItemName", "BBalance", "BBAmount", "ReceivedQty", "ReceivedAmount", "IssuedQty", "IssuedAmount", "LossesQty", "LossesAmount", "AdjustedQty", "AdjustedAmount", "SOH", "SOHAmount", "Received", "ID", "CategoryId", "SubCategoryID" };
            int i = 0;
            foreach (string s in col)
            {
                if (i > 0)
                {
                    dtResult.Columns.Add(s,typeof(double));
                }
                else
                {
                    dtResult.Columns.Add(s);
                }
                i++;
            }
            DataTable dtItem = ((selectedType == "Drug") ? itm.GetAllItems(1) : itm.GetAllSupply());
            foreach (DataRow dr in dtItem.Rows)
            {
                string itemName = dr["FullItemName"].ToString();// +" - " + dr["DosageForm"].ToString() + " - " + dr["Strength"].ToString();
                int itemId = Convert.ToInt32(dr["ID"]);
                Int64 bb = yEnd.GetBBalance(year, storeId, itemId, month);                
                double bbAmount = yEnd.GetBBalanceAmount(year, storeId, itemId, month);
                Int64 recQuant = rec.GetReceivedQuantityTillMonth(itemId, storeId, month, year);
                double recPrice = rec.GetReceivedAmountTillMonth(itemId, storeId, month, year);
                Int64 issuedQuant = iss.GetIssuedQuantityTillMonth(itemId, storeId, month, year);
                double issPrice = iss.GetIssuedAmountTillMonth(itemId, storeId, month, year);
                Int64 lossQuant = dis.GetLossesQuantityTillMonth(itemId, storeId, month, year);
                double lossAmount = dis.GetLossesAmountTillMonth(itemId, storeId, month, year);
                Int64 adjQuant = dis.GetAdjustedQuantityTillMonth(itemId, storeId, month, year);
                double adjAmount = dis.GetAdjustedAmountTillMonth(itemId, storeId, month, year);
                Int64 SOH = bb + recQuant + adjQuant - issuedQuant - lossQuant;
                double SOHAmount = (bbAmount + recPrice + adjAmount - issPrice) - lossAmount;
                if (SOHAmount < 0)
                {
                    ;
                }
                
                int Isrec = ((bb == 0 && recQuant == 0) ? 0 : 1);
                object[] obj = { itemName, bb, bbAmount, recQuant, recPrice, issuedQuant, issPrice, lossQuant, lossAmount, adjQuant, adjAmount, SOH, SOHAmount, Isrec, itemId, Convert.ToInt32(dr["CategoryId"]), Convert.ToInt32(dr["SubCategoryID"]) };
                dtResult.Rows.Add(obj);
            }
            return dtResult;
        }


        public DataTable TransactionReport(int storeId, DateTime dt1, DateTime dt2, string selectedType, BackgroundWorker bw)
        {
            //IssueDoc iss = new IssueDoc();
            //ReceiveDoc rec = new ReceiveDoc();
            //Disposal dis = new Disposal();
            //YearEnd yEnd = new YearEnd();
            //Items itm = new Items();
            //DataTable dtResult = new DataTable();
            //DateTime dt1;
            //DateTime dt2;
            //int yr;
            //    //do quarter date range and all year if quarter is null
            //    switch (quarter)
            //    {
            //        case 1:
            //            yr = year - 1;
            //            dt1 = new DateTime(yr, 11, 1);
            //            dt2 = new DateTime(year, 1, 30);
            //            break;
            //       case 2:
            //            dt1 = new DateTime(year, 2, 1);
            //            dt2 = new DateTime(year, 4, 30);
            //            break;
            //       case 3:
            //            dt1 = new DateTime(year, 5, 1);
            //            dt2 = new DateTime(year, 7, 30);
            //            break;
            //       case 4:
            //            dt1 = new DateTime(year, 8, 1);
            //            dt2 = new DateTime(year, 10, 30);
            //            break;
            //        default :
            //            yr = (month < 11) ? year - 1 : year; 
            //            dt1 = new DateTime(yr, 11,1);
            //            dt2 = new DateTime(year, 10, 30);
            //         break;
            //    }
           
            //string[] col = { "FullItemName", "ReceivedQty", "ReceivedAmount", "IssuedQty", "IssuedAmount", "Received", "ID", "CategoryId", "SubCategoryID" };

            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@fromdate", dt1);
            ld.Add("@todate", dt2);

            ////this.LoadFromSqlNoExec("SOH", ld);
            this.LoadFromSql("GetTransactionDetails", ld, CommandType.StoredProcedure);
            return this.DataTable;
            //int i = 0;
            //foreach (string s in col)
            //{
            //    if (i > 0)
            //    {
            //        dtResult.Columns.Add(s, typeof(double));
            //    }
            //    else
            //    {
            //        dtResult.Columns.Add(s);
            //    }
            //    i++;
            //}
            //DataTable dtItem = ((selectedType == "Drug") ? itm.GetAllItems(1) : itm.GetAllSupply());
            //foreach (DataRow dr in dtItem.Rows)
            //{
            //    string itemName = dr["FullItemName"].ToString();
            //    int itemId = Convert.ToInt32(dr["ID"]);
            //    Int64 recQuant = rec.GetReceivedQtyByDateRange(itemId, storeId, dt1, dt2);
            //    double recPrice = rec.GetReceivedAmountByDateRange(itemId, storeId, dt1, dt2);
            //    Int64 issuedQuant = iss.GetIssuedQuantityByDateRange(itemId, storeId, dt1, dt2);
            //    double issPrice = iss.GetIssuedAmountByDateRange(itemId, storeId, dt1, dt2);

            //    int Isrec = ((recQuant == 0) ? 0 : 1);
            //    object[] obj = { itemName, recQuant, recPrice, issuedQuant, issPrice, Isrec, itemId, Convert.ToInt32(dr["CategoryId"]), Convert.ToInt32(dr["SubCategoryID"]) };
            //    dtResult.Rows.Add(obj);
            //}
            //return dtResult;
        }

        //SupplyListToIssue
        public DataTable ItemListToIssue(int storeId, DateTime dtCurrent,string selectedType)
        {
            GeneralInfo pipline = new GeneralInfo();
            DataTable dtList = new DataTable();
            string[] str = { "No", "Stock Code", "FullItemName", "Unit", "SOH", "AMC", "Expired", "CategoryId", "SubCategoryID", "ID", "Status", "IsSelected" };
            foreach (string s in str)
            {
                dtList.Columns.Add(s);
            }
            dtList.Columns[11].DataType = typeof(bool);
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
           // int storeId = (cboStores.SelectedValue != null) ? Convert.ToInt32(cboStores.SelectedValue) : 1;

            
            int count = 1;
            Balance bal = new Balance();
            Items itmB = new Items();
            DataTable dtItem = ((selectedType == "Drug")? itmB.GetAllItems(1) : itmB.GetAllSupply());
            int curYear = dtCurrent.Year;
            int curMonth = dtCurrent.Month;
            foreach (DataRow dr in dtItem.Rows)
            {
                int yer = (curMonth < 11) ? curYear : curYear - 1;
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, curMonth, curYear);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                double beloweopCon = AMC * (eop - 0.25);
                Int64 soh = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, curMonth, curYear);
                string status = (soh <= eopCon && soh > beloweopCon) ? "Near EOP" : ((soh > 0 && soh <= beloweopCon) ? "Below EOP" : ((soh > maxCon && maxCon != 0) ? "Excess Stock" : ((soh <= 0) ? "Stock Out" : "Normal")));//((SOH > beloweopCon && SOH <= MinCon) ? "Below Min" : ((SOH > maxCon && maxCon != 0) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
                string itemName = dr["FullItemName"].ToString();
                Int64 expAmount = itmB.GetExpiredQtyItemsByID(Convert.ToInt32(dr["ID"]), storeId);
                object[] obj = { count.ToString(), dr["StockCode"].ToString(), itemName, dr["Unit"].ToString(), soh, AMC, expAmount ,Convert.ToInt32(dr["CategoryId"]), Convert.ToInt32(dr["SubCategoryID"]), Convert.ToInt32(dr["ID"]),status,DBNull.Value };
                dtList.Rows.Add(obj);
                count++;
            }
            return dtList;
        }

        public DataTable ItemListToIssue(int storeId, DateTime dtCurrent, string selectedType, BackgroundWorker bw)
        {
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            // string query = string.Format("SOH  {0}, '{1}', '{2}', {3}, {4}, {5}, {6} ", storeId,dtCurrent.Subtract(new TimeSpan(360,0,0,0,0)),dtCurrent,pipline.AMCRange,pipline.Min,pipline.Max,pipline.EOP);
            var ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@month", dtCurrent.Month);
            ld.Add("@year", dtCurrent.Year);
            ld.Add("@days", DateTime.DaysInMonth(dtCurrent.Year,dtCurrent.Month));
            //ld.Add("@amcrange", pipline.AMCRange);
            //ld.Add("@min", pipline.Min);
            //ld.Add("@max", pipline.Max);
            //ld.Add("@eop", pipline.EOP);

            //this.LoadFromSqlNoExec("SOH", ld);

            this.LoadFromSql("SOH", ld, CommandType.StoredProcedure);

           // Add the necessary fields
            this.DataTable.Columns.Add("IsSelected", typeof(bool));
            //this.DataTable.Columns.Add("NewAMC", typeof (double));

            //foreach (DataRow row in this.DataTable.Rows)
            //{
            //    row.BeginEdit();
            //   // row["NewAMC"] = Builder.CachedAMC((int)row["ID"], storeId);

            //}
            return this.DataTable;

            //this.Exe
        }

        public long GetBeginningBalance(int year, int item, int storeID)
        {
            YearEnd yearEnd = new YearEnd();
            yearEnd.LoadByItemIDStoreAndYear(item, storeID, year- 1,false);
            if (yearEnd.RowCount > 0)
            {
                return yearEnd.PhysicalInventory;
            }
            return 0;
        }
    }
}

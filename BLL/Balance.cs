
// Generated by MyGeneration Version # (1.3.0.3)

using System;
using System.Linq;
using DAL;
using System.Data;
using System.ComponentModel;
using StockoutIndexBuilder;

namespace BLL
{
    /// <summary>
    /// A proxy class to deal with any Item balance related functionality
    /// </summary>
    public class Balance : _Balance
    {
        public Balance()
        {

        }

        public DataTable GetBalance(int itemId, int storeId, int month, int year)
        {
            this.FlushData();
            this.Where.WhereClauseReset();
            this.Where.ItemID.Value = itemId;
            this.Where.StoreId.Conjuction = MyGeneration.dOOdads.WhereParameter.Conj.And;
            this.Where.StoreId.Value = storeId;
            this.Where.Month.Conjuction = MyGeneration.dOOdads.WhereParameter.Conj.And;
            this.Where.Month.Value = month;
            this.Where.Year.Conjuction = MyGeneration.dOOdads.WhereParameter.Conj.And;
            this.Where.Year.Value = year;
            this.Query.Load();
            return this.DataTable;
        }

        public static int GetChangeAfterDate(int itemID, int storeID, DateTime date)
        {
            BLL.Balance bal = new Balance();
            string query = String.Format(@"select
                                            ISNULL((select Quantity from receivedoc 
                                            where ItemID={0} and StoreID={1} and Date>{2}),0)
                                            -
                                            ISNULL((select Quantity from IssueDoc 
                                            where ItemID={0} and StoreId={1} and Date>{2}),0)
                                            +
                                            ISNULL((select Quantity from Disposal where 
                                            ItemID={0} and StoreId={1} and Losses<>1 and Date>{2}),0)
                                            -
                                            ISNULL((select Quantity from Disposal where 
                                            ItemID={0} and StoreId={1} and Losses=1 and Date>{2}),0)
                                            as Qty", itemID, storeID, date);
            bal.FlushData();
            bal.LoadFromRawSql(query);
            return int.Parse(bal.GetColumn("Qty").ToString());
        }

        public DataTable GetLastBalance(int itemId, int storeId)
        {
            this.FlushData();
            this.LoadFromRawSql(String.Format("SELECT TOP(1) * FROM Balance WHERE ItemID = {0} AND StoreId= {1} ORDER BY Year DESC, Month DESC", itemId, storeId));
            return this.DataTable;
        }

        public DataTable GetCurrentSOHAsOfDate(int itemId, int storeId, DateTime date)
        {

            this.FlushData();
            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@month", date.Month);
            ld.Add("@year", date.Year);
            ld.Add("@days", DateTime.DaysInMonth(date.Year, date.Month));

            this.LoadFromSql("SOH", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }

        /// <summary>
        /// Makes sure that every quantity in the Loss/Adjustment table is entered as positive.
        /// The Losses are entered with positive quantity and with the Losses bit set to 1.
        /// The adjustments are entered with positive quantity and with the Losses bit set to 0.
        /// </summary>
        public static void GetAndFixLossAdjustmentInconsistencies()
        {
            const string fixQuery = "update disposal set quantity=0-quantity where quantity<0";
            BLL.Balance bal = new Balance();
            bal.LoadFromRawSql(fixQuery);
        }

        /// <summary>
        /// Takes care of double entries in the Inventory Table.  One entered manually and another entered automatically
        /// </summary>
        public static void GetAndFixInventoryInconsistencies()
        {
            const string fixQuery = "delete from yearend where automaticallyentered=1 and itemid in (select itemid from yearend group by itemid,storeid,year having count(*)>1)";
            BLL.Balance bal = new Balance();
            bal.LoadFromRawSql(fixQuery);
        }
        public static void GetAndFixInventorydetailInconsistencies()
        {
            const string fixQuery = "DELETE FROM dbo.YearEndDetail WHERE yearendid IN(SELECT ID from yearend where automaticallyentered=1 and itemid in (select itemid from yearend group by itemid,storeid,year having count(*)>1))";
            BLL.Balance bal = new Balance();
            bal.LoadFromRawSql(fixQuery);
        }


        /// <summary>
        /// Gets the average monthly consumption of an item
        /// This method considers the logical store
        /// </summary>
        /// <param name="itemId"></param>
        /// <param name="storeId"></param>
        /// <param name="month"></param>
        /// <param name="year"></param>
        /// <returns></returns>
        public Int64 CalculateAMC(int itemId, int storeId, int month, int year)
        {
            GeneralInfo info = new GeneralInfo();
            info.LoadAll();
            int range = info.AMCRange;
            Int64 cons = 0;
            IssueDoc iss = new IssueDoc();
            int yr = year;// (month > 10) ? year - 1 : year;

            DateTime dt1 = new DateTime(yr, month, DateTime.DaysInMonth(yr, month));
            DateTime dt2 = dt1.AddMonths(-range);
            range = iss.GetAvailableNoOfMonths(itemId, storeId, dt2, dt1);
            cons = iss.GetIssuedQuantityByDateRange(itemId, storeId, dt2, dt1);
            Int64 AMC = cons / range;
            return AMC;
        }

        /// <summary>
        /// Gets Average Monthly consumption, without considering logical stores
        /// </summary>
        /// <param name="itemId"></param>
        /// <param name="month"></param>
        /// <param name="year"></param>
        /// <returns></returns>
        public Int64 CalculateAMCAll(int itemId, int month, int year)
        {
            GeneralInfo info = new GeneralInfo();
            info.LoadAll();
            int range = info.AMCRange;
            Int64 cons = 0;
            IssueDoc iss = new IssueDoc();
            int yr = (month > 10) ? year - 1 : year;

            DateTime dt1 = new DateTime(yr, month, DateTime.DaysInMonth(yr, month));
            DateTime dt2 = dt1.AddMonths(-range);
            range = iss.GetAvailableNoOfMonthsAll(itemId, dt2, dt1);

            cons = iss.GetIssuedQuantityByDateRangeAll(itemId, dt2, dt1);

            Int64 AMC = cons / range;
            return AMC;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="itemId"></param>
        /// <param name="storeId"></param>
        /// <param name="mon"></param>
        /// <param name="yr"></param>
        /// <returns></returns>
        public Int64 CalculateSOH(int itemId, int storeId, int mon, int yr)
        {
            //ask by normal u get soh on fiscal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();

            int month = (mon > 2) ? mon - 2 : ((mon == 1) ? 11 : 12);
            int year = (mon > 2) ? yr : yr - 1;
            Int64 cons = 0;
            cons = (rec.GetReceivedQuantityTillMonth(itemId, storeId, month, year) + dis.GetAdjustedQuantityTillMonth(itemId, storeId, month, year) - iss.GetIssuedQuantityTillMonth(itemId, storeId, month, year) - dis.GetLossesQuantityTillMonth(itemId, storeId, month, year));

            return cons;
        }

        /// <summary>
        /// Gets SOH of a specific item for the end of the specified Ethipian Fiscal Month Item
        /// </summary>
        /// <param name="itemId"></param>
        /// <param name="storeId"></param>
        /// <param name="month"></param>
        /// <param name="year"></param>
        /// <returns></returns>

        public Int64 GetSOHOld(int itemId, int storeId, int month, int year)
        {
            //ask by normal u get soh on normal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            //int month = (mon > 2) ? mon - 2 : ((mon == 1) ? 11 : 12);
            //int year = (mon > 2) ? yr : yr - 1;
            Int64 cons = 0;
            long recievedQuantity = rec.GetReceivedQuantityTillMonth(itemId, storeId, month, year);
            long adjustedQuantity = dis.GetAdjustedQuantityTillMonth(itemId, storeId, month, year);
            long issuedQuantity = iss.GetIssuedQuantityTillMonth(itemId, storeId, month, year);
            long lossQuantity = dis.GetLossesQuantityTillMonth(itemId, storeId, month, year);
            long balanceQuantity = yEnd.GetBBalance(year, storeId, itemId, month);
            cons = (balanceQuantity + recievedQuantity + adjustedQuantity - issuedQuantity - lossQuantity);
            this.FlushData();
            // this.LoadFromRawSql(String.Format("SELECT SUM(QuantityLeft) AS Quantity FROM ReceiveDoc WHERE (ItemID = {0}) AND (StoreID = {1} AND ((Month(Date) <= {2} AND Year(Date) = {3}) OR (Month(Date) > 10 AND Year(Date) = {4})))", itemId, storeId, month, year, year - 1));

            // cons = (this.DataTable.Rows[0]["Quantity"].ToString() != "") ? Convert.ToInt64(this.DataTable.Rows[0]["Quantity"]) : 0;

            return cons;

        }

        public double GetSOHAmount(int itemId, int storeId, int month, int year)
        {
            //ask by normal u get soh on normal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            //int month = (mon > 2) ? mon - 2 : ((mon == 1) ? 11 : 12);
            //int year = (mon > 2) ? yr : yr - 1;
            double cons = 0;
            cons = (yEnd.GetBBalanceAmount(year, storeId, itemId, month) + rec.GetReceivedAmount(itemId, storeId, year) + dis.GetAdjustedAmount(itemId, storeId, year) - iss.GetIssuedAmount(itemId, storeId, year) - dis.GetLossesAmount(itemId, storeId, year));
            this.FlushData();
            // this.LoadFromRawSql(String.Format("SELECT SUM(QuantityLeft) AS Quantity FROM ReceiveDoc WHERE (ItemID = {0}) AND (StoreID = {1} AND ((Month(Date) <= {2} AND Year(Date) = {3}) OR (Month(Date) > 10 AND Year(Date) = {4})))", itemId, storeId, month, year, year - 1));

            // cons = (this.DataTable.Rows[0]["Quantity"].ToString() != "") ? Convert.ToInt64(this.DataTable.Rows[0]["Quantity"]) : 0;

            return cons;
        }

        public Int64 GetSOHAll(int itemId, int month, int year)
        {
            //ask by normal u get soh on normal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            Int64 cons = 0;
            cons = (yEnd.GetBBalanceAll(year, itemId) + rec.GetReceivedQuantityTillMonthAll(itemId, month, year) + dis.GetAdjustedQuantityTillMonthAll(itemId, month, year) - iss.GetIssuedQuantityTillMonthAll(itemId, month, year) - dis.GetLossesQuantityTillMonthAll(itemId, month, year));
            this.FlushData();
            return cons;
        }

        public Int64 GetSOHPastMonth(int itemId, int storeId, int month, int year)
        {
            //ask by normal u get soh on normal month
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            //int month = (mon > 2) ? mon - 2 : ((mon == 1) ? 11 : 12);
            //int year = (mon > 2) ? yr : yr - 1;
            Int64 cons = 0;
            cons = (rec.GetReceivedQuantityPastMonth(itemId, storeId, month, year) + dis.GetAdjustedQuantityPastMonth(itemId, storeId, month, year) - iss.GetIssuedQuantityPastMonth(itemId, storeId, month, year) - dis.GetLossesQuantityPastMonth(itemId, storeId, month, year));
            this.FlushData();
            // this.LoadFromRawSql(String.Format("SELECT SUM(QuantityLeft) AS Quantity FROM ReceiveDoc WHERE (ItemID = {0}) AND (StoreID = {1} AND ((Month(Date) <= {2} AND Year(Date) = {3}) OR (Month(Date) > 10 AND Year(Date) = {4})))", itemId, storeId, month, year, year - 1));

            // cons = (this.DataTable.Rows[0]["Quantity"].ToString() != "") ? Convert.ToInt64(this.DataTable.Rows[0]["Quantity"]) : 0;

            return cons;

        }

        public Int64 GetSOHperMonth(int itemId, int storeId, int month, int year)
        {
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            //int month = (mon > 2) ? mon - 2 : ((mon == 1) ? 11 : 12);
            //int year = (mon > 2) ? yr : yr - 1;
            Int64 cons = 0;
            cons = (this.GetSOH(itemId, storeId, month - 1, year) + rec.GetReceivedQuantityPerMonth(itemId, storeId, month, year) + dis.GetAdjustedQuantityPerMonth(itemId, storeId, month, year) - iss.GetIssuedQuantityPerMonth(itemId, storeId, month, year) - dis.GetLossesQuantityPerMonth(itemId, storeId, month, year));

            return cons;
        }

        public int CountStockIn(int storeId, int month, int year)
        {

            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                         where m["Status"].ToString() == "Normal"
                         select m).AsDataView().Count;
            return items;
        }

        public int CountStockInByCategory(int storeId, int month, int year ,int typeID)
        {
            GetSOH(storeId, month, year);
            int items;
            if (typeID != 0)
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Normal" && Convert.ToInt32(m["ID"]) == typeID
                             select m).AsDataView().Count;
            }
            else
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Normal"
                             select m).AsDataView().Count;
            }
            return items;
        }

        public int CountBelowMin(int storeId, int month, int year)
        {
            Items itm = new Items();
            DataTable dtItem = itm.GetAllItems(1);
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            int count = 0;
            Balance bal = new Balance();
            if (storeId == 0)
            {
                count += (from DataRow dr in dtItem.Rows
                          let AMC = bal.CalculateAMCAll(Convert.ToInt32(dr["ID"]), month, year)
                          let MinCon = AMC * min
                          let maxCon = AMC * max
                          let eopCon = AMC * (eop + 0.25)
                          let SOH = bal.GetSOHAll(Convert.ToInt32(dr["ID"]), month, year)
                          let MOS = (AMC != 0) ? (SOH / AMC) : 0
                          let reorder = (maxCon > SOH) ? maxCon - SOH : 0
                          where SOH > eopCon && (SOH <= MinCon)
                          select MinCon).Count();
            }
            else
            {
                count += (from DataRow dr in dtItem.Rows
                          let AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year)
                          let MinCon = AMC * min
                          let maxCon = AMC * max
                          let eopCon = AMC * (eop + 0.25)
                          let SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year)
                          let MOS = (AMC != 0) ? (SOH / AMC) : 0
                          let reorder = (maxCon > SOH) ? maxCon - SOH : 0
                          where SOH > eopCon && (SOH <= MinCon)
                          select MinCon).Count();
            }
            return count;
        }

        public DataTable GetStockIn(int storeId, int month, int year ,int typeId)
        {
            GetSOH(storeId, month, year);
            if (typeId != 0)
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Normal" && Convert.ToInt32(m["TypeID"]) == typeId
                                   select m).CopyToDataTable();
                return items;
            }
            else
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Normal"
                                   select m).CopyToDataTable();
                return items;
            }
        }

        public DataTable GetBelowMin(int storeId, int month, int year)
        {
            Items itm = new Items();
            DataTable dtItem = itm.GetAllItems(1);
            DataTable dt = new DataTable();
            string[] cols = { "ID", "ItemName", "DosageForm", "Strength", "Unit", "StockCode" };
            foreach (string st in cols)
            {
                dt.Columns.Add(st);
            }
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;

            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                if (SOH > eopCon && (SOH <= MinCon))
                {
                    object[] obb = { dr["ID"], dr["ItemName"], dr["DosageForm"], dr["Strength"], dr["Unit"], dr["StockCode"] };
                    dt.Rows.Add(obb);
                }
                //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            }
            return dt;
        }

        public int CountNearEOP(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                         where m["Status"].ToString() == "Near EOP"
                         select m).AsDataView().Count;
            return items;
        }

        public int CountNearEOPByCategory(int storeId, int month, int year ,int typeID)
        {
            GetSOH(storeId, month, year);
            int items;
            if (typeID != 0)
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Near EOP" && Convert.ToInt32(m["TypeID"]) == typeID
                             select m).AsDataView().Count;
            }
            else
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Near EOP"
                             select m).AsDataView().Count;
            }
            return items;
        }

        public int CountBelowEOP(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                         where m["Status"].ToString() == "Below EOP"
                         select m).AsDataView().Count;
            return items;

        }


        public int CountBelowEOPByCategory(int storeId, int month, int year ,int typeID)
        {
            GetSOH(storeId, month, year);
            int items;
            if (typeID != 0)
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Below EOP" && Convert.ToInt32(m["ID"]) == typeID
                             select m).AsDataView().Count;
            }
            else
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Below EOP" && Convert.ToInt32(m["ID"]) == typeID
                             select m).AsDataView().Count;
            }
            return items;

        }

        public DataTable GetNearEOP(int storeId, int month, int year, int typeId)
        {
            GetSOH(storeId, month, year);
            if (typeId != 0)
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Near EOP" && Convert.ToInt32(m["TypeID"]) == typeId
                                   select m).CopyToDataTable();
                return items;
            }
            else
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Near EOP"
                                   select m).CopyToDataTable();
                return items;
            }
        }

        public DataTable GetBelowEOP(int storeId, int month, int year, int typeId)
        {
            GetSOH(storeId, month, year);
            if (typeId != 0)
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Below EOP" && Convert.ToInt32(m["TypeID"]) == typeId
                                   select m).CopyToDataTable();
                return items;
            }
            else
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Below EOP"
                                   select m).CopyToDataTable();
                return items;
            }
        }

        public int CountStockOut(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                         where m["Status"].ToString() == "Stock Out" //&& (Convert.ToInt32(m["SOH"]) > 0 || Convert.ToInt32(m["AMC"]) > 0)
                         select m).AsDataView().Count;
            return items;

        }

        public int CountStockOutByCategory(int storeId, int month, int year ,int typeID)
        {
            GetSOH(storeId, month, year);
            int items;

            if (typeID != 0)
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Stock Out" && Convert.ToInt32(m["TypeID"]) == typeID
                             select m).AsDataView().Count;
            }
            else
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Stock Out"
                             select m).AsDataView().Count;
            }
            return items;

        }

        public DataTable GetStockOut(int storeId, int month, int year, int typeId)
        {
            GetSOH(storeId, month, year);
            if (typeId != 0)
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Stock Out" && Convert.ToInt32(m["TypeID"]) == typeId
                                   select m).CopyToDataTable();
                return items;
            }
            else
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Stock Out"
                                   select m).CopyToDataTable();
                return items;
            }

        }

        public DataTable GetReceivedStockOut(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            DataTable items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Stock Out" && Convert.ToInt32(m["Received"]) > 0
                               select m).CopyToDataTable();
            return items;

        }

        public int CountOverStock(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                         where m["Status"].ToString() == "Over Stocked"
                         select m).AsDataView().Count;
            return items;


        }

        public int CountOverStockByCategory(int storeId, int month, int year ,int typeID)
        {
            GetSOH(storeId, month, year);
            int items;
            if (typeID != 0)
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Over Stocked" && Convert.ToInt32(m["TypeID"]) == typeID
                             select m).AsDataView().Count;
            }
            else
            {
                items = (from m in this.DataTable.AsEnumerable()
                             where m["Status"].ToString() == "Over Stocked"
                             select m).AsDataView().Count;
            }
            return items;


        }

        public DataTable GetOverStock(int storeId, int month, int year, int typeId)
        {
            GetSOH(storeId, month, year);
            if (typeId != 0)
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Over Stocked" && Convert.ToInt32(m["TypeID"]) == typeId
                                   select m).CopyToDataTable();
                return items;
            }
            else
            {
                DataTable items = (from m in this.DataTable.AsEnumerable()
                                   where m["Status"].ToString() == "Over Stocked"
                                   select m).CopyToDataTable();
                return items;
            }

        }

        public int CountFreeItemsStockOut(int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            int items = (from m in this.DataTable.AsEnumerable()
                         where m["Status"].ToString() == "Stock Out" && (Convert.ToInt32(m["AMC"]) > 0 || Convert.ToInt32(m["SOH"]) > 0)
                         select m).AsDataView().Count;
            return items;

        }

        public DataTable GetFreeItemsStockOut(int storeId, int month, int year ,int typeId)
        {

            GetSOH(storeId, month, year);
            DataTable items = (from m in this.DataTable.AsEnumerable()
                               where m["Status"].ToString() == "Stock Out" && Convert.ToInt32(m["TypeID"]) == typeId
                               select m).CopyToDataTable();
            return items;

        }

        public int CountVitalItemsStockOut(int storeId, int month, int year)
        {
            Items itm = new Items();
            DataTable dtItem = itm.GetVitalItems();
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            int count = 0;
            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 minCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                if (SOH == 0)
                    count++;
                //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            }
            return count;
        }

        public int CountVitalItemsStockOutForAllStore(int month, int year)
        {
            Items itm = new Items();
            DataTable dtItem = itm.GetVitalItems();
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            int count = 0;
            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMCAll(Convert.ToInt32(dr["ID"]), month, year);
                Int64 minCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOHForAllStore(Convert.ToInt32(dr["ID"]), month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                if (SOH == 0)
                    count++;
                //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            }
            return count;
        }

        public int CountECLSItemsStockOut(int storeId, int month, int year)
        {
            Items itm = new Items();
            Programs prog = new Programs();
            prog.GetProgramByName("Family Planning");
            DataTable dtItem = itm.GetItemsByProgram(prog.ID);
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            int count = 0;
            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                if (SOH == 0)
                    count++;
                //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            }
            return count;
        }

        public DataTable GetECLSItemsStockOut(int storeId, int month, int year)
        {
            Items itm = new Items();
            Programs prog = new Programs();
            prog.GetProgramByName("Family Planning");
            DataTable dtItem = itm.GetItemsByProgram(prog.ID);
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;

            DataTable dt = new DataTable();
            string[] cols = { "ID", "FullItemName", "DosageForm", "Strength", "Unit", "StockCode" };
            foreach (string st in cols)
            {
                dt.Columns.Add(st);
            }
            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;

                if (SOH == 0)
                {
                    object[] obb = { dr["ID"], dr["ItemName"], dr["DosageForm"], dr["Strength"], dr["Unit"], dr["StockCode"] };
                    dt.Rows.Add(obb);
                }
                //string status = (SOH <= eopCon && SOH > 0) ? "Near EOP" : ((SOH > maxCon) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
            }
            return dt;
        }

        public DataTable GetVitalItemsStockOut(int storeId, int month, int year)
        {
            Items itm = new Items();
            DataTable dtItem = itm.GetVitalItems();
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();

            DataTable dt = new DataTable();
            string[] cols = { "ID", "ItemName", "DosageForm", "Strength", "Unit", "StockCode" };
            foreach (string st in cols)
            {
                dt.Columns.Add(st);
            }

            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;

            Balance bal = new Balance();
            foreach (DataRow dr in dtItem.Rows)
            {
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, year);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, year);
                decimal MOS = (AMC != 0) ? (SOH / AMC) : 0;
                Int64 reorder = (maxCon > SOH) ? maxCon - SOH : 0;
                if (SOH == 0)
                {
                    object[] obb = { dr["ID"], dr["ItemName"], dr["DosageForm"], dr["Strength"], dr["Unit"], dr["StockCode"] };
                    dt.Rows.Add(obb);
                }
            }
            return dt;
        }

        //DU Info

        public Int64 CalculateDUAMC(int itemId, int receivingUnit, int month, int year, int LastSOH)
        {
            GeneralInfo info = new GeneralInfo();
            info.LoadAll();
            int range = 3;
            try
            {
                range = info.DUAMCRange;
            }
            catch
            { }
            Int64 cons = 0;
            IssueDoc iss = new IssueDoc();

            int yr = (month > 10) ? year + 1 : year;

            DateTime dt1 = new DateTime(yr, month, DateTime.DaysInMonth(yr, month));
            DateTime dt2 = dt1.AddMonths(-range);
            int mon = dt2.Month;
            range = iss.GetAvailableNoOfMonthsDU(itemId, receivingUnit, dt2, dt1);
            yr = (mon > 10) ? year + 1 : year;
            cons = iss.GetDUConsumptionAfterMonth(itemId, receivingUnit, mon, yr);

            //for (int m = mon+1; m < month; m++ )
            //{
            //    yr = (m > 10) ? year - 1 : year;
            //    cons = cons + iss.GetDUConsumptionByMonth(itemId, receivingUnit, m, yr);
            //}
            yr = (month > 10) ? year + 1 : year;
            //yr = (month > 10) ? year : year  + 1 ;
            //Int64 lastIss = iss.GetDUIssueByMonth(itemId, receivingUnit, month, yr);
            Int64 lastIss = iss.GetDULastIssueQty(itemId, receivingUnit);
            // lastIss = ((lastIss > 0)? (lastIss - LastSOH) : lastIss );
            cons = cons + lastIss - LastSOH;
            //cons = cons - LastSOH;
            cons = ((cons > 0) ? cons : 0);
            Int64 AMC = cons / range;
            return AMC;
        }

        public Int64 GetDUSOH(int itemID, int receivingUnit, int month, int year)
        {
            Int64 quantity = 0;
            int yr = ((month > 10) ? year : year + 1);
            IssueDoc iss = new IssueDoc();
            quantity = iss.GetDUSOHByMonth(itemID, receivingUnit, month, yr);
            return quantity;
        }

        public DataTable CostBalanceByYear(int storeId, int year, int month, BackgroundWorker bw)
        {
            DataTable dtBal = new DataTable();
            GeneralInfo pipline = new GeneralInfo();

            // Dont Iterate
            DataTable dtbl = new DataTable();
            dtbl = GetSOH(storeId, month, year);
            return dtbl;
        }

        public DataTable ConsumptionByUnit(int storeId, int year, int programID, BackgroundWorker bw)
        {
            // Dont Iterate
            DataTable dtbl = new DataTable();
            //if (programID == 0) //We don't filter by program ID.
            //{
            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@year", year);

            ////this.LoadFromSqlNoExec("SOH", ld);
            this.LoadFromSql("GetMonthlyConsumptionByUnits", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }

        public DataTable ConsumptionTrendByMonth(int storeId, int year, int programID, BackgroundWorker bw)
        {
            // Dont Iterate
            DataTable dtbl = new DataTable();
            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@year", year);
            this.LoadFromSql("GetConsumptionTrendByMonth", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }


        public DataTable BalanceOfAllItems(int storeId, int year, int month, string selectedType, int programID, int commodityTypeID, DateTime dtCurrent, BackgroundWorker bw)
        {  
            // Dont Iterate
            var dtbl = new DataTable();
            dtbl = programID == 0 ? GetSOH(storeId, month, year) : GetSOHByPrograms(storeId, programID, month, year);
            dtbl.Columns.Add("MOS", typeof(float));
            dtbl.Columns.Add("ReorderAmount", typeof(int));
            foreach (DataRow dr in dtbl.Rows)
            {
                int amc = Convert.ToInt32(dr["AMC"]);
                if (amc > 0)
                {
                    dr["MOS"] = Convert.ToDouble(dr["SOH"]) / amc;
                }
                else
                {
                    dr["MOS"] = 0;
                }
                int reorder = Convert.ToInt32(dr["Max"]) - Convert.ToInt32(dr["SOH"]);
                dr["ReorderAmount"] = (reorder < 0) ? 0 : reorder;

            }
            return dtbl;

        }

        public DataTable BalanceOfAllItemsForStockStatus(int storeId, int year, int month, string selectedType, int programID, int commodityTypeID, DateTime dtCurrent, BackgroundWorker bw)
        {
            // Dont Iterate
            var dtbl = new DataTable();
            dtbl = programID == 0 ? GetSOH(storeId, month, year) : GetSOHByPrograms(storeId, programID, month, year);
            dtbl.Columns.Add("MOS", typeof(float));
            dtbl.Columns.Add("ReorderAmount", typeof(int));
            foreach (DataRow dr in dtbl.Rows)
            {
                int amc = Convert.ToInt32(dr["AMC"]);
                if (amc > 0)
                {
                    dr["MOS"] = Convert.ToDouble(dr["SOH"]) / amc;
                }
                else
                {
                    dr["MOS"] = 0;
                }
                int reorder = Convert.ToInt32(dr["Max"]) - Convert.ToInt32(dr["SOH"]);
                dr["ReorderAmount"] = (reorder < 0) ? 0 : reorder;

            }
            return dtbl;

        }

        public DataTable BalanceOfAllItemsForStockoutReport(int storeId, int year, int month, string selectedType, int programID, int commodityTypeID, DateTime dtCurrent, BackgroundWorker bw)
        {
            // Dont Iterate
            var dtbl = new DataTable();
            dtbl = programID == 0 ? GetSOHForStockOutReport(storeId, month, year) : GetSOHByPrograms(storeId, programID, month, year);
            dtbl.Columns.Add("MOS", typeof(float));
            dtbl.Columns.Add("ReorderAmount", typeof(int));
            foreach (DataRow dr in dtbl.Rows)
            {
                int amc = Convert.ToInt32(dr["AMC"]);
                if (amc > 0)
                {
                    dr["MOS"] = Convert.ToDouble(dr["SOH"]) / amc;
                }
                else
                {
                    dr["MOS"] = 0;
                }
                int reorder = Convert.ToInt32(dr["Max"]) - Convert.ToInt32(dr["SOH"]);
                dr["ReorderAmount"] = (reorder < 0) ? 0 : reorder;

            }
            return dtbl;

        }

        public DataTable GetSOHForAllStores(int month, int year)
        {
            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@month", month},
                             {"@year", year},
                             {"@days", DateTime.DaysInMonth(year, month)}
                         };
            this.LoadFromSql("SOHForAllStores", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }

        public DataTable GetSOH(int storeId, int month, int year)
        {
            if (storeId == 0)
            {
                return GetSOHForAllStores(month, year);
            }
            else
            {
                var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@month", month},
                             {"@year", year},
                             {"@days", DateTime.DaysInMonth(year, month)}
                         };
                this.LoadFromSql("SOH", ld, CommandType.StoredProcedure);
                return this.DataTable;
            }
        }

        public DataTable GetSOHOptimizedDB(int storeId, int itemid, int month, int year)
        {
            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@itemid", itemid},
                             {"@month", month},
                             {"@year", year},
                             {"@days", DateTime.DaysInMonth(year, month)}
                         };
            this.LoadFromSql("SOHOptimized", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }

        public DataTable GetSOHForStockOut(int storeId, int month, int year)
        {
            var startDate = EthiopianDate.EthiopianDate.EthiopianToGregorian(String.Format("{0}/{1}/{2}", 1, month, year));
            var endDate = EthiopianDate.EthiopianDate.EthiopianToGregorian(String.Format("{0}/{1}/{2}", 30, month, year));

            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@startDate", startDate},
                             {"@endDate", endDate}
                         };
            this.LoadFromSql("SOHForDOSOnly", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }

        public DataTable GetSOHForStockOutReport(int storeId, int month, int year)
        {
            GeneralInfo generalInfo = new GeneralInfo();
            generalInfo.LoadAll();            

            var startDate = EthiopianDate.EthiopianDate.EthiopianToGregorian(String.Format("{0}/{1}/{2}", 1, month, year));
            var endDate = DateTime.Today;//EthiopianDate.EthiopianDate.EthiopianToGregorian(String.Format("{0}/{1}/{2}", 30, month, year));
            var diff = endDate.Subtract(startDate.AddMonths(-(generalInfo.AMCRange - 1)));
            var balancer = 0;

            if (diff.Days > (generalInfo.AMCRange * 30))
            {
                balancer = diff.Days - (generalInfo.AMCRange * 30);
            }

            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@startDate", startDate.AddMonths(-(generalInfo.AMCRange-1)).AddDays(balancer)},
                             {"@endDate", endDate}
                         };
            this.LoadFromSql("SOHForDOSOnly", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }
        public DataTable GetSOHForProgramRRF(int storeId, int month, int year)
        {
            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@month", month},
                             {"@year", year},
                             {"@days", DateTime.DaysInMonth(year, month)}
                         };
            this.LoadFromSql("SOHByProgram", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }

        public Int64 GetSOH(int itemID, int storeId, int month, int year)
        {
            GetSOH(storeId, month, year);
            while (!this.EOF)
            {
                if (this.ID == itemID)
                {
                    return this.SOH;
                }
                this.MoveNext();
            }
            return 0;
        }

        public Int64 GetSOHForAllStore(int itemID, int month, int year)
        {
            GetSOHForAllStores(month, year);
            while (!this.EOF)
            {
                if (this.ID == itemID)
                {
                    return this.SOH;
                }
                this.MoveNext();
            }
            return 0;
        }

        public Int64 GetSOHOptimized(int itemID, int storeId, int month, int year)
        {
            GetSOHOptimizedDB(storeId, itemID, month, year);
            while (!this.EOF)
            {
                if (this.ID == itemID)
                {
                    return this.SOH;
                }
                this.MoveNext();
            }
            return 0;
        }
        public Int64 GetSOHByUnit(int itemID, int storeId, int month, int year, int unitID)
        {
            GetSOHByUnit(storeId, month, year);
            while (!this.EOF)
            {
                if (this.ID == itemID && this.UnitID==unitID)
                {
                    return this.SOH;
                }
                this.MoveNext();
            }
            return 0;
        }

        public Int64 GetSOHByUnitOptimized(int itemID, int storeId, int month, int year, int unitID)
        {
            //bereket
            GetSOHByUnitOptimizedDB(storeId, itemID, unitID, month, year);
            while (!this.EOF)
            {
                if (this.ID == itemID && this.UnitID==unitID)
                {
                    return this.SOH;
                }
                this.MoveNext();
            }
            return 0;
        }

        public DataTable GetSOHByUnit(int storeId, int month, int year)
        {
            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@month", month},
                             {"@year", year},
                             {"@days", DateTime.DaysInMonth(year, month)}
                         };
            this.LoadFromSql("SOHByUnit", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }


        public DataTable GetSOHByUnitForRRF(int storeId, int month, int year)
        {
            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@month", month},
                             {"@year", year},
                             {"@days", DateTime.DaysInMonth(year, month)}
                         };
            this.LoadFromSql("SOHByUnitByProgram", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }
        public DataTable GetSOHByUnitOptimizedDB(int storeId, int itemid, int unitid, int month, int year)
        {
            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@itemid", itemid},
                             {"@unitid", unitid},
                             {"@month", month},
                             {"@year", year},
                             {"@days", DateTime.DaysInMonth(year, month)}
                         };

            this.LoadFromSql("SOHByUnitOptimized", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }

        public DataTable GetBinCard(int storeID, int itemID, int year)
        {
            var ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@StoreID", storeID);
            ld.Add("@ItemID", itemID);
            ld.Add("@Year", year);

            LoadFromSql("rpt_Bincard", ld, CommandType.StoredProcedure);
            //return this.DataTable;
            // Set the balance  
            int balance = (int)GetBeginningBalance(year, itemID, storeID);
            while (!EOF)
            {
                balance += Convert.ToInt32(GetColumn("Balance"));
                SetColumn("Balance", balance);
                MoveNext();
            }

            return this.DataTable;
        }

        public DataTable GetBinCard2(int storeID, int itemID, int year, int unitID)
        {
            var ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@StoreID", storeID);
            ld.Add("@ItemID", itemID);
            ld.Add("@Year", year);
            ld.Add("@UnitID", unitID);

            LoadFromSql("rpt_BincardByUnit", ld, CommandType.StoredProcedure);
            //return this.DataTable;
            // Set the balance  
            int balance = (int)GetBeginningBalance(year, itemID, storeID);
            while (!EOF)
            {
                balance += Convert.ToInt32(GetColumn("Balance"));
                SetColumn("Balance", balance);
                MoveNext();
            }

            return this.DataTable;
        }

        public DataTable GetSOHByPrograms(int storeId, int programid, int month, int year)
        {
            var days = DateTime.DaysInMonth(year, month);
            var ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@progID", programid);
            ld.Add("@month", month);
            ld.Add("@year", year);
            ld.Add("@days", days);
            this.LoadFromSql("SOHByPrograms", ld, CommandType.StoredProcedure);
            //TODO: filter out by commodity type here.

            return this.DataTable;

        }

        public DataTable GetSOHToDate(int storeId, DateTime dt)
        {
            GeneralInfo pipline = new GeneralInfo();
            pipline.LoadAll();

            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@date1", dt);

            ld.Add("@amcrange", pipline.AMCRange);
            ld.Add("@min", pipline.Min);
            ld.Add("@max", pipline.Max);
            ld.Add("@eop", pipline.EOP);

            //this.LoadFromSqlNoExec("SOH", ld);
            this.LoadFromSql("SOHByDate", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }


        public DataTable OverStockedItems(int storeId, int year, int month, string selectedType, BackgroundWorker bw)
        {
            DataTable dtBal = new DataTable();
            GeneralInfo pipline = new GeneralInfo();
            Items itm = new Items();
            Balance bal = new Balance();
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            string[] str = { "FullItemName", "SOH", "AMC", "MOS", "Min", "Max", "ExcessQty", "ExcessAmount", "CategoryId", "SubCategoryID", "ID" };
            foreach (string s in str)
            {
                dtBal.Columns.Add(s);
            }
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            DataTable dtItem = new DataTable();

            dtItem = ((selectedType == "Drug") ? itm.GetAllItems(1) : itm.GetAllSupply());
            int i = 1;
            foreach (DataRow dr in dtItem.Rows)
            {

                string itemName = dr["FullItemName"].ToString();
                int yer = (month < 11) ? year : year - 1;
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, month, yer);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                Int64 SOH = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, month, yer);
                if (SOH > maxCon)
                {
                    decimal MOS = (AMC != 0) ? (Convert.ToDecimal(SOH) / Convert.ToDecimal(AMC)) : 0;
                    MOS = Decimal.Round(MOS, 1);

                    Int64 excessQty = SOH - maxCon;
                    double price = rec.GetLastReceivedCost(Convert.ToInt32(dr["ID"]), storeId);
                    double excessAmount = price * excessQty;
                    object[] obj = { itemName, SOH, AMC, MOS, MinCon, maxCon, excessQty, excessAmount, Convert.ToInt32(dr["CategoryId"]), Convert.ToInt32(dr["SubCategoryID"]), Convert.ToInt32(dr["ID"]) };
                    dtBal.Rows.Add(obj);
                }
                bw.ReportProgress(Convert.ToInt32((Convert.ToDouble(i++) / dtItem.Rows.Count) * 100));
            }
            return dtBal;
        }

        public DataTable BalanceAllItems(int storeId, int year, int month, string selectedType)
        {
            IssueDoc iss = new IssueDoc();
            ReceiveDoc rec = new ReceiveDoc();
            Disposal dis = new Disposal();
            YearEnd yEnd = new YearEnd();
            Items itm = new Items();
            DataTable dtResult = new DataTable();
            string[] col = { "FullItemName", "BBalance", "BBAmount", "ReceivedQty", "ReceivedAmount", "IssuedQty", "IssuedAmount", "LossesQty", "LossesAmount", "AdjustedQty", "AdjustedAmount", "SOH", "SOHAmount", "Received", "ID", "CategoryId", "SubCategoryID" };
            int i = 0;
            foreach (string s in col)
            {
                if (i > 0)
                {
                    dtResult.Columns.Add(s, typeof(double));
                }
                else
                {
                    dtResult.Columns.Add(s);
                }
                i++;
            }
            DataTable dtItem = ((selectedType == "Drug") ? itm.GetAllItems(1) : itm.GetAllSupply());
            foreach (DataRow dr in dtItem.Rows)
            {
                string itemName = dr["FullItemName"].ToString();// +" - " + dr["DosageForm"].ToString() + " - " + dr["Strength"].ToString();
                int itemId = Convert.ToInt32(dr["ID"]);
                Int64 bb = yEnd.GetBBalance(year, storeId, itemId, month);
                double bbAmount = yEnd.GetBBalanceAmount(year, storeId, itemId, month);
                Int64 recQuant = rec.GetReceivedQuantityTillMonth(itemId, storeId, month, year);
                double recPrice = rec.GetReceivedAmountTillMonth(itemId, storeId, month, year);
                Int64 issuedQuant = iss.GetIssuedQuantityTillMonth(itemId, storeId, month, year);
                double issPrice = iss.GetIssuedAmountTillMonth(itemId, storeId, month, year);
                Int64 lossQuant = dis.GetLossesQuantityTillMonth(itemId, storeId, month, year);
                double lossAmount = dis.GetLossesAmountTillMonth(itemId, storeId, month, year);
                Int64 adjQuant = dis.GetAdjustedQuantityTillMonth(itemId, storeId, month, year);
                double adjAmount = dis.GetAdjustedAmountTillMonth(itemId, storeId, month, year);
                Int64 SOH = bb + recQuant + adjQuant - issuedQuant - lossQuant;
                double SOHAmount = (bbAmount + recPrice + adjAmount - issPrice) - lossAmount;
                if (SOHAmount < 0)
                {
                    ;
                }

                int Isrec = ((bb == 0 && recQuant == 0) ? 0 : 1);
                object[] obj = { itemName, bb, bbAmount, recQuant, recPrice, issuedQuant, issPrice, lossQuant, lossAmount, adjQuant, adjAmount, SOH, SOHAmount, Isrec, itemId, Convert.ToInt32(dr["CategoryId"]), Convert.ToInt32(dr["SubCategoryID"]) };
                dtResult.Rows.Add(obj);
            }
            return dtResult;
        }


        public DataTable TransactionReport(int storeId, DateTime dt1, DateTime dt2, string selectedType, BackgroundWorker bw)
        {
            System.Collections.Specialized.ListDictionary ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@fromdate", dt1);
            ld.Add("@todate", dt2);
            this.LoadFromSql("GetTransactionDetails", ld, CommandType.StoredProcedure);
            return this.DataTable;

        }

        //SupplyListToIssue
        public DataTable ItemListToIssue(int storeId, DateTime dtCurrent, string selectedType)
        {
            GeneralInfo pipline = new GeneralInfo();
            DataTable dtList = new DataTable();
            string[] str = { "No", "Stock Code", "FullItemName", "Unit", "SOH", "AMC", "Expired", "CategoryId", "SubCategoryID", "ID", "Status", "IsSelected" };
            foreach (string s in str)
            {
                dtList.Columns.Add(s);
            }
            dtList.Columns[11].DataType = typeof(bool);
            pipline.LoadAll();
            int min = pipline.Min;
            int max = pipline.Max;
            double eop = pipline.EOP;
            // int storeId = (cboStores.SelectedValue != null) ? Convert.ToInt32(cboStores.SelectedValue) : 1;


            int count = 1;
            Balance bal = new Balance();
            Items itmB = new Items();
            DataTable dtItem = ((selectedType == "Drug") ? itmB.GetAllItems(1) : itmB.GetAllSupply());
            int curYear = dtCurrent.Year;
            int curMonth = dtCurrent.Month;
            foreach (DataRow dr in dtItem.Rows)
            {
                int yer = (curMonth < 11) ? curYear : curYear - 1;
                Int64 AMC = bal.CalculateAMC(Convert.ToInt32(dr["ID"]), storeId, curMonth, curYear);
                Int64 MinCon = AMC * min;
                Int64 maxCon = AMC * max;
                double eopCon = AMC * (eop + 0.25);
                double beloweopCon = AMC * (eop - 0.25);
                Int64 soh = bal.GetSOH(Convert.ToInt32(dr["ID"]), storeId, curMonth, curYear);
                string status = (soh <= eopCon && soh > beloweopCon) ? "Near EOP" : ((soh > 0 && soh <= beloweopCon) ? "Below EOP" : ((soh > maxCon && maxCon != 0) ? "Excess Stock" : ((soh <= 0) ? "Stock Out" : "Normal")));//((SOH > beloweopCon && SOH <= MinCon) ? "Below Min" : ((SOH > maxCon && maxCon != 0) ? "Excess Stock" : ((SOH <= 0) ? "Stock Out" : "Normal"));
                string itemName = dr["FullItemName"].ToString();
                Int64 expAmount = itmB.GetExpiredQtyItemsByID(Convert.ToInt32(dr["ID"]), storeId);
                object[] obj = { count.ToString(), dr["StockCode"].ToString(), itemName, dr["Unit"].ToString(), soh, AMC, expAmount, Convert.ToInt32(dr["CategoryId"]), Convert.ToInt32(dr["SubCategoryID"]), Convert.ToInt32(dr["ID"]), status, DBNull.Value };
                dtList.Rows.Add(obj);
                count++;
            }
            return dtList;
        }

        public DataTable ItemListToIssue(int storeId, DateTime dtCurrent, string selectedType, BackgroundWorker bw)
        {
            var pipline = new GeneralInfo();
            pipline.LoadAll();
            var ld = new System.Collections.Specialized.ListDictionary();
            ld.Add("@storeid", storeId);
            ld.Add("@month", dtCurrent.Month);
            ld.Add("@year", dtCurrent.Year);
            ld.Add("@days", DateTime.DaysInMonth(dtCurrent.Year, dtCurrent.Month));

            this.LoadFromSql("SOH", ld, CommandType.StoredProcedure);

            this.DataTable.Columns.Add("IsSelected", typeof(bool)); 
                return this.DataTable;
        }


        public DataTable ItemsListToIssueByUnit(int storeId, DateTime dtCurrent, string selectedType, BackgroundWorker bw)
        {
            var pipline = new GeneralInfo();
            pipline.LoadAll();
            int days = DateTime.DaysInMonth(dtCurrent.Year, dtCurrent.Month);
            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@month", dtCurrent.Month},
                             {"@year", dtCurrent.Year},
                             {"@days", days}
                         };
            this.LoadFromSql("SOHByUnit", ld, CommandType.StoredProcedure);
            this.DataTable.Columns.Add("IsSelected", typeof(bool));
            return this.DataTable;
        }
        public long GetBeginningBalance(int year, int item, int storeID)
        {
            YearEnd yearEnd = new YearEnd();
            yearEnd.LoadByItemIDStoreAndYear(item, storeID, year - 1, false);
            if (yearEnd.RowCount > 0)
            {
                return yearEnd.PhysicalInventory;
            }
            return 0;
        }

        public long GetBeginningBalanceByUnit(int year, int item, int storeID,int unitID)
        {
            var yearEnd = new YearEnd();
            yearEnd.LoadByItemIDStoreAndYearAndUnit(item, storeID, year - 1, false,unitID);
            if (yearEnd.RowCount > 0)
            {
                return yearEnd.PhysicalInventory;
            }
            return 0;
        }

        public object BalanceOfAllItemsUsingUnit(int storeId, int year, int month, string _selectedType, int programID, int commodityTypeID, DateTime _dtCur, BackgroundWorker bw)
        {
            // Dont Iterate
            var dtbl = new DataTable();
            dtbl = programID == 0 ? GetSOHByUnit(storeId, month, year) : GetSOHByPrograms(storeId, programID, month, year);
            dtbl.Columns.Add("MOS", typeof(float));
            dtbl.Columns.Add("ReorderAmount", typeof(int));
            foreach (DataRow dr in dtbl.Rows)
            {
                var amc = Convert.ToInt32(dr["AMC"]);
                if (amc > 0)
                {
                    dr["MOS"] = Convert.ToDouble(dr["SOH"]) / amc;
                }
                else
                {
                    dr["MOS"] = 0;
                }
                // 
                int reorder = Convert.ToInt32(dr["Max"]) - Convert.ToInt32(dr["SOH"]);
                dr["ReorderAmount"] = (reorder < 0) ? 0 : reorder;

            }
            return dtbl;
        }

        public DataTable GetSOHForRRF(int storeId, int month, int year)
        {
            var ld = new System.Collections.Specialized.ListDictionary
                         {
                             {"@storeid", storeId},
                             {"@month", month},
                             {"@year", year},
                             {"@days", DateTime.DaysInMonth(year, month)}
                         };
            this.LoadFromSql("SOHForRRF", ld, CommandType.StoredProcedure);
            return this.DataTable;
        }
    }
}
